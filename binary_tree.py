# -*- coding: utf-8 -*-
"""Binary Tree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TNCgUuDDHeG81ENZ7IcQezfadZbs4kmZ
"""

class BinarySearchTreeNode:
  #Binary search can have two element max and left have smaller value and right have higher values than root node
  def __init__(self,data):
    self.data = data
    self.left = None
    self.right = None

  def add_child(self,data):
    if data == self.data:
      return

    if data < self.data:
      # add data in left subtree
      if self.left:
        self.left.add_child(data)
      else:
        self.left = BinarySearchTreeNode(data)

    else:
      # add data in right subtree
      if self.right:
        self.right.add_child(data)
      else:
        self.right = BinarySearchTreeNode(data)

  def in_order_traversal(self):
    elements = []

    #visit left tree
    if self.left:
      elements += self.left.in_order_traversal()

    #visit base node
    elements.append(self.data)

    #visit right tree
    if self.right:
      elements +=  self.right.in_order_traversal()

    return elements

  def search(self, val):
    if self.data == val:
      return True

    if val < self.data:
      #val might be in left subtree
      if self.left:
        return self.left.search(val)
      else:
        return False

    if val > self.data:
      #val might be in right subtree
      if self.right:
        return self.right.search(val)
      else:
        return False

  def find_min(self):
    if self.left:
      return self.left.find_min()
    else:
      return self.data

  def find_max(self):
    if self.right:
      return self.right.find_max()
    else:
      return self.data

  def calculate_sum(self):
    left_sum = self.left.calculate_sum() if self.left else 0
    right_sum = self.right.calculate_sum() if self.right else 0
    return self.data + left_sum + right_sum

  def delete(self,val):
    if val < self.data:
      if self.left:
        self.left = self.left.delete(val)
    elif val > self.data:
      if self.right:
       self.right =  self.right.delete(val)

    else:
      if self.left is None and self.right is None:
        return None

      if self.left is None:
        return self.right

      if self.right is None:
        return self.left

      min_val = self.right.find_min()
      self.data = min_val
      self.right = self.right.delete(min_val)

    return self

def build_tree(elements):
  root = BinarySearchTreeNode(elements[0])

  for i in range(1,len(elements)):
    root.add_child(elements[i])

  return root

numbers = [17, 4, 1, 20, 9, 23, 18, 34]
number_tree = build_tree(numbers)
print(number_tree.in_order_traversal())

number_tree.delete(20)
print("After the deleting 20",number_tree.in_order_traversal())

number_tree.delete(7)
print("After the deleting 9",number_tree.in_order_traversal())
print("After the deleting 1",number_tree.in_order_traversal())

print(number_tree.search(41))

countries = ["India","Australia","Germany","USA","China","India","UK","USA"]
country_tree = build_tree(countries)

print("UK is in the list?",country_tree.search('UK'))
print("Nepal is in the list?",country_tree.search('Nepal'))

print(number_tree.find_min())
print(number_tree.find_max())
print(number_tree.calculate_sum())